# SQLite Database Schema Design

## Overview

This document defines the database schema for DocsUnmessed's SQLite persistence layer.

---

## Schema Version: 1.0

### Design Goals

1. **Efficient Storage**: Store 100k+ files with minimal overhead
2. **Fast Queries**: Optimized indexes for common query patterns
3. **Audit Trail**: Complete history of operations
4. **Flexibility**: Support for future features
5. **Portability**: Single file database for easy backup

---

## Tables

### 1. Scans

Stores metadata about file system scans.

```sql
CREATE TABLE Scans (
    ScanId TEXT PRIMARY KEY,
    ProviderId TEXT NOT NULL,
    RootPath TEXT NOT NULL,
    StartedAt TEXT NOT NULL,
    CompletedAt TEXT NULL,
    Status TEXT NOT NULL,  -- Pending, Running, Complete, Failed
    TotalItems INTEGER DEFAULT 0,
    TotalSize INTEGER DEFAULT 0,
    TotalFiles INTEGER DEFAULT 0,
    TotalFolders INTEGER DEFAULT 0,
    ErrorMessage TEXT NULL,
    Configuration TEXT NULL,  -- JSON
    CreatedAt TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
    UpdatedAt TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_scans_status ON Scans(Status);
CREATE INDEX idx_scans_provider ON Scans(ProviderId);
CREATE INDEX idx_scans_started ON Scans(StartedAt DESC);
```

**Fields**:
- `ScanId`: Unique identifier (GUID)
- `ProviderId`: Storage provider (fs_local, onedrive, etc.)
- `RootPath`: Root path that was scanned
- `StartedAt`: Scan start timestamp
- `CompletedAt`: Scan completion timestamp (NULL if in progress)
- `Status`: Current scan status
- `TotalItems/Size/Files/Folders`: Aggregate statistics
- `ErrorMessage`: Error details if failed
- `Configuration`: Scan configuration (JSON)

---

### 2. Items

Stores individual file and folder metadata.

```sql
CREATE TABLE Items (
    ItemId TEXT PRIMARY KEY,
    ScanId TEXT NOT NULL,
    Type TEXT NOT NULL,  -- File, Folder
    Name TEXT NOT NULL,
    Path TEXT NOT NULL,
    Extension TEXT NULL,
    SizeBytes INTEGER DEFAULT 0,
    Hash TEXT NULL,
    CreatedUtc TEXT NULL,
    ModifiedUtc TEXT NULL,
    AccessedUtc TEXT NULL,
    ParentPath TEXT NULL,
    Depth INTEGER DEFAULT 0,
    IsHidden INTEGER DEFAULT 0,
    IsSystem INTEGER DEFAULT 0,
    Attributes TEXT NULL,  -- JSON
    Metadata TEXT NULL,    -- JSON
    FOREIGN KEY (ScanId) REFERENCES Scans(ScanId) ON DELETE CASCADE
);

CREATE INDEX idx_items_scan ON Items(ScanId);
CREATE INDEX idx_items_type ON Items(Type);
CREATE INDEX idx_items_hash ON Items(Hash) WHERE Hash IS NOT NULL;
CREATE INDEX idx_items_path ON Items(Path);
CREATE INDEX idx_items_extension ON Items(Extension) WHERE Extension IS NOT NULL;
CREATE INDEX idx_items_modified ON Items(ModifiedUtc DESC);
CREATE INDEX idx_items_size ON Items(SizeBytes DESC);
```

**Fields**:
- `ItemId`: Unique identifier (GUID)
- `ScanId`: Reference to parent scan
- `Type`: File or Folder
- `Name`: File/folder name
- `Path`: Full path
- `Extension`: File extension (without dot)
- `SizeBytes`: File size in bytes
- `Hash`: SHA-256 hash for files
- `CreatedUtc/ModifiedUtc/AccessedUtc`: Timestamps
- `ParentPath`: Parent directory path
- `Depth`: Folder depth from root
- `IsHidden/IsSystem`: Boolean flags
- `Attributes/Metadata`: JSON for extensibility

---

### 3. Rules

Stores rule configurations for file organization.

```sql
CREATE TABLE Rules (
    RuleId TEXT PRIMARY KEY,
    Name TEXT NOT NULL UNIQUE,
    Type TEXT NOT NULL,  -- RegexPath, Extension, AgeBased, Composite
    Priority INTEGER NOT NULL DEFAULT 100,
    IsEnabled INTEGER DEFAULT 1,
    Configuration TEXT NOT NULL,  -- JSON
    Description TEXT NULL,
    CreatedAt TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
    UpdatedAt TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
    LastUsedAt TEXT NULL,
    UsageCount INTEGER DEFAULT 0
);

CREATE INDEX idx_rules_priority ON Rules(Priority DESC, IsEnabled);
CREATE INDEX idx_rules_type ON Rules(Type);
CREATE INDEX idx_rules_enabled ON Rules(IsEnabled);
```

**Fields**:
- `RuleId`: Unique identifier (GUID)
- `Name`: Rule name (unique)
- `Type`: Rule type
- `Priority`: Evaluation priority (higher first)
- `IsEnabled`: Whether rule is active
- `Configuration`: Rule-specific config (JSON)
- `Description`: Human-readable description
- `LastUsedAt`: Last time rule was used
- `UsageCount`: Number of times rule matched

---

### 4. Suggestions

Stores file organization suggestions generated by rules.

```sql
CREATE TABLE Suggestions (
    SuggestionId TEXT PRIMARY KEY,
    ScanId TEXT NOT NULL,
    ItemId TEXT NOT NULL,
    RuleId TEXT NULL,
    SourcePath TEXT NOT NULL,
    SourceName TEXT NOT NULL,
    TargetPath TEXT NOT NULL,
    TargetName TEXT NOT NULL,
    Confidence REAL NOT NULL,
    Reasons TEXT NULL,  -- JSON array
    ConflictPolicy TEXT NOT NULL,
    Status TEXT NOT NULL DEFAULT 'Pending',  -- Pending, Accepted, Rejected, Applied
    CreatedAt TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
    AppliedAt TEXT NULL,
    FOREIGN KEY (ScanId) REFERENCES Scans(ScanId) ON DELETE CASCADE,
    FOREIGN KEY (ItemId) REFERENCES Items(ItemId) ON DELETE CASCADE,
    FOREIGN KEY (RuleId) REFERENCES Rules(RuleId) ON DELETE SET NULL
);

CREATE INDEX idx_suggestions_scan ON Suggestions(ScanId);
CREATE INDEX idx_suggestions_item ON Suggestions(ItemId);
CREATE INDEX idx_suggestions_rule ON Suggestions(RuleId);
CREATE INDEX idx_suggestions_status ON Suggestions(Status);
CREATE INDEX idx_suggestions_confidence ON Suggestions(Confidence DESC);
```

**Fields**:
- `SuggestionId`: Unique identifier (GUID)
- `ScanId/ItemId/RuleId`: Foreign keys
- `SourcePath/SourceName`: Current location
- `TargetPath/TargetName`: Suggested location
- `Confidence`: Confidence score (0.0-1.0)
- `Reasons`: Why this suggestion was made (JSON)
- `ConflictPolicy`: How to handle conflicts
- `Status`: Current status
- `AppliedAt`: When suggestion was applied

---

### 5. MigrationPlans

Stores migration plan metadata.

```sql
CREATE TABLE MigrationPlans (
    PlanId TEXT PRIMARY KEY,
    ScanId TEXT NOT NULL,
    Name TEXT NOT NULL,
    Status TEXT NOT NULL DEFAULT 'Draft',  -- Draft, Ready, Running, Paused, Complete, Failed
    TotalOperations INTEGER DEFAULT 0,
    CompletedOperations INTEGER DEFAULT 0,
    FailedOperations INTEGER DEFAULT 0,
    TotalFiles INTEGER DEFAULT 0,
    TotalSize INTEGER DEFAULT 0,
    StartedAt TEXT NULL,
    CompletedAt TEXT NULL,
    Configuration TEXT NULL,  -- JSON
    Metrics TEXT NULL,  -- JSON
    CreatedAt TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
    UpdatedAt TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (ScanId) REFERENCES Scans(ScanId) ON DELETE CASCADE
);

CREATE INDEX idx_plans_scan ON MigrationPlans(ScanId);
CREATE INDEX idx_plans_status ON MigrationPlans(Status);
CREATE INDEX idx_plans_created ON MigrationPlans(CreatedAt DESC);
```

**Fields**:
- `PlanId`: Unique identifier (GUID)
- `ScanId`: Reference to scan
- `Name`: Plan name
- `Status`: Current status
- `TotalOperations`: Total operations in plan
- `CompletedOperations`: Operations completed
- `FailedOperations`: Operations that failed
- `Metrics`: Plan metrics (JSON)

---

### 6. MigrationOperations

Stores individual migration operations.

```sql
CREATE TABLE MigrationOperations (
    OperationId TEXT PRIMARY KEY,
    PlanId TEXT NOT NULL,
    ItemId TEXT NULL,
    Type TEXT NOT NULL,  -- Copy, Move, Delete, Rename
    SourcePath TEXT NOT NULL,
    TargetPath TEXT NOT NULL,
    Status TEXT NOT NULL DEFAULT 'Pending',  -- Pending, Running, Complete, Failed, Skipped
    Priority INTEGER DEFAULT 0,
    ErrorMessage TEXT NULL,
    StartedAt TEXT NULL,
    CompletedAt TEXT NULL,
    VerificationHash TEXT NULL,
    Metadata TEXT NULL,  -- JSON
    FOREIGN KEY (PlanId) REFERENCES MigrationPlans(PlanId) ON DELETE CASCADE,
    FOREIGN KEY (ItemId) REFERENCES Items(ItemId) ON DELETE SET NULL
);

CREATE INDEX idx_operations_plan ON MigrationOperations(PlanId);
CREATE INDEX idx_operations_status ON MigrationOperations(Status);
CREATE INDEX idx_operations_type ON MigrationOperations(Type);
CREATE INDEX idx_operations_priority ON MigrationOperations(Priority DESC);
```

**Fields**:
- `OperationId`: Unique identifier (GUID)
- `PlanId`: Reference to migration plan
- `ItemId`: Reference to item (nullable)
- `Type`: Operation type
- `SourcePath/TargetPath`: Operation paths
- `Status`: Current status
- `Priority`: Execution priority
- `VerificationHash`: Hash for verification

---

### 7. AuditLog

Stores audit trail of all operations.

```sql
CREATE TABLE AuditLog (
    LogId TEXT PRIMARY KEY,
    Timestamp TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
    UserId TEXT NULL,
    Action TEXT NOT NULL,
    EntityType TEXT NOT NULL,
    EntityId TEXT NULL,
    Details TEXT NULL,  -- JSON
    Success INTEGER NOT NULL DEFAULT 1,
    ErrorMessage TEXT NULL
);

CREATE INDEX idx_audit_timestamp ON AuditLog(Timestamp DESC);
CREATE INDEX idx_audit_action ON AuditLog(Action);
CREATE INDEX idx_audit_entity ON AuditLog(EntityType, EntityId);
CREATE INDEX idx_audit_success ON AuditLog(Success);
```

**Fields**:
- `LogId`: Unique identifier (GUID)
- `Timestamp`: When action occurred
- `UserId`: User identifier (future use)
- `Action`: Action performed (Create, Update, Delete, etc.)
- `EntityType`: Type of entity affected
- `EntityId`: ID of entity affected
- `Details`: Additional details (JSON)
- `Success`: Whether action succeeded

---

### 8. Duplicates

Stores detected duplicate files.

```sql
CREATE TABLE Duplicates (
    DuplicateGroupId TEXT PRIMARY KEY,
    Hash TEXT NOT NULL,
    FileCount INTEGER DEFAULT 0,
    TotalSize INTEGER DEFAULT 0,
    FirstSeenAt TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
    LastSeenAt TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE UNIQUE INDEX idx_duplicates_hash ON Duplicates(Hash);
CREATE INDEX idx_duplicates_count ON Duplicates(FileCount DESC);
```

**Fields**:
- `DuplicateGroupId`: Unique identifier (GUID)
- `Hash`: SHA-256 hash of duplicate files
- `FileCount`: Number of duplicates found
- `TotalSize`: Total size of all duplicates
- `FirstSeenAt/LastSeenAt`: Discovery timestamps

---

### 9. DuplicateItems

Links items to duplicate groups.

```sql
CREATE TABLE DuplicateItems (
    DuplicateGroupId TEXT NOT NULL,
    ItemId TEXT NOT NULL,
    IsPrimary INTEGER DEFAULT 0,
    PRIMARY KEY (DuplicateGroupId, ItemId),
    FOREIGN KEY (DuplicateGroupId) REFERENCES Duplicates(DuplicateGroupId) ON DELETE CASCADE,
    FOREIGN KEY (ItemId) REFERENCES Items(ItemId) ON DELETE CASCADE
);

CREATE INDEX idx_duplicate_items_group ON DuplicateItems(DuplicateGroupId);
CREATE INDEX idx_duplicate_items_item ON DuplicateItems(ItemId);
```

**Fields**:
- `DuplicateGroupId`: Reference to duplicate group
- `ItemId`: Reference to item
- `IsPrimary`: Whether this is the primary (keeper) copy

---

## Relationships

```
Scans 1:N Items
Scans 1:N Suggestions
Scans 1:N MigrationPlans

Items 1:N Suggestions
Items N:M DuplicateGroups (via DuplicateItems)

Rules 1:N Suggestions

MigrationPlans 1:N MigrationOperations
```

---

## Data Types

**SQLite Types Used**:
- `TEXT`: Strings, GUIDs, JSON, timestamps (ISO 8601)
- `INTEGER`: Numbers, booleans (0/1), counts
- `REAL`: Floating point (confidence scores)

**Timestamps**: Stored as ISO 8601 text: `YYYY-MM-DD HH:MM:SS.SSS`

**JSON**: Complex data stored as JSON text for flexibility

---

## Query Patterns

### Common Queries

**Get items from scan**:
```sql
SELECT * FROM Items WHERE ScanId = ? AND Type = 'File';
```

**Find duplicates**:
```sql
SELECT Hash, COUNT(*) as Count, SUM(SizeBytes) as TotalSize
FROM Items
WHERE Hash IS NOT NULL
GROUP BY Hash
HAVING COUNT(*) > 1;
```

**Get suggestions for scan**:
```sql
SELECT s.*, i.Name, i.Path
FROM Suggestions s
JOIN Items i ON s.ItemId = i.ItemId
WHERE s.ScanId = ?
ORDER BY s.Confidence DESC;
```

**Get active rules**:
```sql
SELECT * FROM Rules
WHERE IsEnabled = 1
ORDER BY Priority DESC;
```

**Get migration plan progress**:
```sql
SELECT
    p.PlanId,
    p.TotalOperations,
    COUNT(CASE WHEN o.Status = 'Complete' THEN 1 END) as Completed,
    COUNT(CASE WHEN o.Status = 'Failed' THEN 1 END) as Failed
FROM MigrationPlans p
LEFT JOIN MigrationOperations o ON p.PlanId = o.PlanId
WHERE p.PlanId = ?
GROUP BY p.PlanId;
```

---

## Performance Considerations

### Indexes

All foreign keys are indexed for join performance.
Common filter columns (Status, Type, Hash) are indexed.
Composite indexes on (Priority, IsEnabled) for rule evaluation.

### Partitioning

For very large datasets (1M+ files), consider:
- Archiving old scans
- Separate databases per provider
- Incremental scans

### JSON Fields

JSON fields provide flexibility but:
- Not indexed (use virtual columns for important fields)
- Parse overhead on read
- Good for metadata and configuration

---

## Migration Strategy

### Version 1.0 (Initial)
- All tables created
- Base indexes applied

### Future Versions
- Use EF Core migrations
- Preserve data during upgrades
- Document breaking changes

---

## Storage Estimates

### Per File Item
- Base row: ~200 bytes
- With metadata: ~500 bytes
- 100k files: ~50 MB
- 1M files: ~500 MB

### Per Suggestion
- Base row: ~150 bytes
- 100k suggestions: ~15 MB

### Database Size
- 100k files + metadata: ~100 MB
- 1M files + metadata: ~1 GB

---

## Backup & Recovery

### Backup
- Single file database
- Copy .db file for backup
- Use `.backup` command for hot backup

### Recovery
- Replace .db file
- Run migrations if schema changed
- Verify with `PRAGMA integrity_check`

---

*Database Schema Version 1.0*  
*Date: January 3, 2025*  
*Status: Design Complete*
